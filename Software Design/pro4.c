#pragma config(Sensor, S3,     noname,         sensorEV3_Touch)
#pragma config(Sensor, S4,     eye,            sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          leftmotor,     tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          arm,           tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          rightmotor,    tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int mycolor,first;
//if robot is blue, mycolor is 1, else mycolor is 0.
//if robot is first, first is 1, else first is 0 
int current_map[5][5];
//this 2-D array saves the current chess board data, 
//if current_map[i][j]==1, that means position (i,j) has robot's ball.
//if current_map[i][j]==2, that means position (i,j) has player's ball.
//if there is no balls at position(i,j), current_map[i][j]==0;
int step;
//step represents how many balls the robot has currently.
int current_position,current_degree;
//current_position saves the current position of the robot(1 to 4) in the map.
//current_degree saves the current direction of the robot(1 to 8).
//You can see details of the map and direction in report.
int belong[4][4];
//we need to set every grid belong to which point manually.
//if we do that, we can know someone grid belong to which point easily,
//we do not need to write some useless code like 
//if (x==1  &&  y==2) then
//position=1
//that can make my code shorter.
int degree[4][4],position_degree[6][6];
//we also need to set every grid the direction relative to the postion whose
//the grid belong to.
//that is the action of degree array.
//And the postion_degree array's action is saving the direction of point
//ralative to the others points.
//The 2 arrays and 'belong' array are very useful for my code.
//they let my code reduce many judgement statement.
int dx[10],dy[10];
//dx means different value x,
//dy means different value y.
//They are use for the Judge function,
//they save eight directions for 2-D,
//for example,if point 5 is (2,2),so if we add dx and dy for this point,
//dx[1]==-1, dy[1]==-1, so the top left point relative to point 5 is (2+dx[1],2+dy[1])
//it is point 1(1,1)
//we can use one loop to check 8 direction of one point.
int win,lose;
//win variable saves the number of win during the simulating(Dfs function)
//lose variable saves the number of failure during the simulating(Dfs function)
float answer;
//answer variable is use in think function,
//it saves the winning rate during Dfs function(simulating process)
//if answer==1, we can say the robot set the ball here, it must win the game,
//if answer==0, we can say the robot set the ball here, it must lose the game,
//answer value is between [0,1], the higher it changes, the better it will be.

void Setball(int encoder);//this function can control droping balls.
void Turn45();//This function can make the robot turn 45 degrees
void Turn_45();//This function can make the robot turn -45 degrees
void Turn(int times);//This function can tell robot the number of Truning 45 degrees
void Move_position();//let robot to move the length of one unit square
void Return(int times);//let robot return to the starting position
void fix();//This function can fix the position and direction of robot
int Judge();//This function can judge who wins the game or no one wins until now
void Dfs(int depth);//This is the process of simulate the remaing games.
int Think();//This function can calculate and determine where it should set the ball
void reset_degree(int p);//Let the robot to be the correct direction
void Search();//Search the ball which the player just set
void Move_to(int x,int y);//Let the car move to the position where nears the (x,y)
//----------------------------------------------------
//if encoder is 1,the control is closed,
//if encoder is -1, the control is open.
void Setball(int encoder)//this function can control droping balls.
{
	if (encoder>0)
			motor[motorB]=10;
	else
			motor[motorB]=-10;

	for (int i=1;i<=100000;i++)
	{}
	motor[motorB]=0;
}
//----------------------------------------------------
void Turn_around()
{
	nMotorEncoder[motorA]=0;
	while (nMotorEncoder[motorA]<393)
	{
		motor[motorA]=10;
		motor[motorD]=-10;
	}
	motor[motorA]=0;
	motor[motorD]=0;
}
//----------------------------------------------------
void Turn45()//This function can make the robot turn 45 degrees
{
	nMotorEncoder[motorA]=0;
	while (nMotorEncoder[motorA]>-105)
	{
			motor[motorA]=-10;
			motor[motorD]=10;
	}
	motor[motorA]=0;
	motor[motorD]=0;
}
//----------------------------------------------------
void Turn_45()//This function can make the robot turn -45 degrees
{
	nMotorEncoder[motorA]=0;
	while (nMotorEncoder[motorA]<102)
	{
			motor[motorD]=-10;
			motor[motorA]=10;
	}
	motor[motorA]=0;
	motor[motorD]=0;
}
//----------------------------------------------------
//times is a variables between [-8,8],
//if times > 0, the robot should turn clockwise 'times'(variable) times,
//else turn counterclockwise times.
void Turn(int times)//This function can tell robot the number of Truning 45 degrees
{
	if (times>0)
	{
		for (int i=0;i<times;i++)
		{
			Turn45();
			current_degree++;
		}
	}
	else
	{
		for (int i=0;i>times;i--)
		{
			Turn_45();
			current_degree--;
		}
	}
}
//----------------------------------------------------
void Move_position()//let robot to move the length of one unit square
{
	Turn(2);//the robot need to turn 90 degrees before go forward,because its direction is the initial direction.
	nMotorEncoder[motorA]=0;
	while (nMotorEncoder[motorA]<650)
	{
		motor[motorA]=10;
		motor[motorD]=10;
	}
	motor[motorA]=0;
	motor[motorD]=0;
}
//----------------------------------------------------
//the times means how many times it should turn 90 degrees and go forward.
void Return(int times)//let robot return to the starting position
{
		while (times--)
		{
			nMotorEncoder[motorA]=0;
			while (nMotorEncoder[motorA]>-650)
			{
				motor[motorA]=-10;
				motor[motorD]=-10;
			}
			motor[motorA]=0;
			motor[motorD]=0;
			Turn(-2);
		}
		current_position=1;
		//reset the current_position variable.
}
//----------------------------------------------------
void fix()//This function can fix the position and direction of robot
{
	nMotorEncoder[motorA]=0;
	while (nMotorEncoder[motorA]<400)
	{
			motor[motorA]=10;
			motor[motorD]=10;
	}

	nMotorEncoder[motorA]=0;
	while (nMotorEncoder[motorA]>-290)
	{
			motor[motorA]=-10;
			motor[motorD]=-10;
	}

	motor[motorA]=0;
	motor[motorD]=0;

	Turn(-2);

	nMotorEncoder[motorA]=0;
	while (nMotorEncoder[motorA]<400)
	{
			motor[motorA]=10;
			motor[motorD]=10;
	}

	nMotorEncoder[motorA]=0;
	while (nMotorEncoder[motorA]>-290)
	{
			motor[motorA]=-10;
			motor[motorD]=-10;
	}

	motor[motorA]=0;
	motor[motorD]=0;

	Turn(2);
}
//----------------------------------------------------
int Judge()//This function can judge who wins the game or no one wins until now
{
		for (int i=1;i<=3;i++)
			for (int j=1;j<=3;j++)
				if (current_map[i][j])
					for (int k=1;k<=4;k++)
						if (current_map[i][j]==current_map[i+dx[k]][j+dy[k]])
							if (current_map[i][j]==current_map[i+dx[9-k]][j+dy[9-k]])
								return current_map[i][j];

		return 0;
}
//----------------------------------------------------
// the depth means how many steps the robot simulates,
// if depth is odd, that means the robot should set the ball
// else the depth is even, that means player should set the ball.
void Dfs(int depth)//This is the process of simulate the remaing games.
{
	if (answer==1  ||  answer==-100) return;
	int temp=Judge();
	//Simulation until now, someone wins
	//if the robot only sets one ball and wins, the robot must win the game with one step,so the 
	//winning rate is 1.
	//if the player only sets one ball and wins, so the robot must lose the game with one step,
	//it cannot set the ball where it supposed, so the winning rate is very very low, so I set 
	//the winning rate is -100
	//if the depth > 2, we cannot say we must win for setting the ball here, so we need to count
	//the cases of winning and failure, and calculate the winning rate at the end.
	if (temp)
	{
		if (depth==1  &&  temp==1) answer=1;
		if (depth==2  &&  temp==2) answer=-100;
		if (temp==1) win++;
		if (temp==2) lose++;
		return;
	}

	for (int i=1;i<=3;i++)
		for (int j=1;j<=3;j++)
			if (!current_map[i][j])
			{
				current_map[i][j]=1+(depth % 2);
				Dfs(depth+1);
				current_map[i][j]=0;
				//this can optimize my code, the answer represents the winning rate,
				//if answer has value, so it can win or lose with one step.
				if (answer>=0)
					return;
			}

	if (answer==1  ||  answer==-100) return;

	if (depth==1)
		if (win+lose!=0)
		{
			float total=win+lose;

			answer=win/total;
		}
		else
			answer=0;
}
//----------------------------------------------------
int Think()//This function can calculate and determine where it should set the ball
{
	if (step==5) return 5;
	//if the robot first, setting the ball in the center is the highest winning rate.
	if (first  &&  step==4)
		for (int i=1;i<=9;i+=2)
			if (!current_map[(i / 3)+1][i % 3]) return i;
	//if the robot first, the second step is set the ball at the corner.
	if (!first  &&  step==4)
	{
		if (!current_map[2][2]) return 5;
		if (current_map[2][2]) return 1;
	}
	//if the robot is not first, the best choice for first step is corner.
	int copy_map[5][5];
	int max_x=-1,max_y=-1;
	float max_answer;
	//save the max winning rate and position.
	max_answer=-10000;
	for (int i=1;i<=3;i++)
		for (int j=1;j<=3;j++)
			copy_map[i][j]=current_map[i][j];
	//because I have some optimization in Dfs, and I changed the current_map but 
	//cannot recover the current_map, so I need a copy current_map array to recover
	//the current_map array.
	for (int i=1;i<=3;i++)
		for (int j=1;j<=3;j++)
		{
			if (current_map[i][j]) continue;
			answer=-1;
			win=0;
			lose=0;
			current_map[i][j]=1;
			Dfs(1);
			current_map[i][j]=0;
			if (answer>max_answer)
			{
				max_answer=answer;
				max_x=i;
				max_y=j;
			}
			for (int k=1;k<=3;k++)
				for (int l=1;l<=3;l++)
					current_map[k][l]=copy_map[k][l];
		}
	return (max_x-1)*3+max_y;//convert 2-D coordinate into 1-D coordinate
}
//----------------------------------------------------
void reset_degree(int p)//Let the robot to be the correct direction
{
		if (p>=5  &&  p<=6) Turn(0-current_degree);
		if (p==7) Turn(2-current_degree);
		if (p>7) Turn(4-current_degree);
}
//----------------------------------------------------
void Search()//Search the ball which the player just set
{
	//the orderx and ordery arrays represent the robot needs to search
	//every grid with this order.
	//if someone grid has ball before, the robot does not need to search this grid,
	//it will skip this position.
		int orderx[10],ordery[10];
		orderx[1]=1; ordery[1]=2; orderx[2]=2; ordery[2]=2;
		orderx[3]=2; ordery[3]=1; orderx[4]=1; ordery[4]=1;
		orderx[5]=1; ordery[5]=3; orderx[6]=2; ordery[6]=3;
		orderx[7]=3; ordery[7]=3; orderx[8]=3; ordery[8]=2;
		orderx[9]=3; ordery[9]=1;

		bool find=false;
		int temp=0;

		for (int i=1;i<=9;i++)
		{
			if (current_map[orderx[i]][ordery[i]])
				continue;
			if (belong[orderx[i]][ordery[i]]!=current_position)
			{
				reset_degree(i);
				Move_position();
				temp++;
				current_position=belong[orderx[i]][ordery[i]];
			}
			Turn(degree[orderx[i]][ordery[i]]-current_degree);
			nMotorEncoder[motorA]=0;
			while (nMotorEncoder[motorA]<300)
			{
				motor[motorA]=10;
				motor[motorD]=10;
			}
			motor[motorA]=0;
			motor[motorD]=0;

			nMotorEncoder[motorA]=0;
			float dis;

			dis=getUSDistance(S4);
			displayCenteredTextLine(4,"%d",dis);
			if (dis<8)
			{
				current_map[orderx[i]][ordery[i]]=2;
				playTone(784, 15);
				find=true;
			}
			nMotorEncoder[motorA]=0;
			displayCenteredTextLine(3,"%d",nMotorEncoder[motorA]);
			while (nMotorEncoder[motorA]>-300)
			{
				motor[motorA]=-10;
				motor[motorD]=-10;
			}
			motor[motorA]=0;
			motor[motorD]=0;

			if (find)
			{
				if (i>=1  &&  i<=4) Turn(0-current_degree);
				if (i>=5  &&  i<=6) Turn(2-current_degree);
				if (i==7) Turn(4-current_degree);
				if (i>7) Turn(6-current_degree);
				break;
			}
		}

		Return(temp);
		fix();
}
//----------------------------------------------------
void Move_to(int x,int y)//Let the car move to the position where nears the (x,y) 
{
	int stock=belong[x][y];
	if (stock==3)
	{
		Turn(4);
		nMotorEncoder[motorA]=0;
		while (nMotorEncoder[motorA]<650)
		{
			motor[motorA]=10;
			motor[motorD]=10;
		}
		motor[motorA]=0;
		motor[motorD]=0;
		Turn(2);
	}
	else
	{
		while (current_position!=stock)
		{
			Turn(2);
			nMotorEncoder[motorA]=0;
			while (nMotorEncoder[motorA]<650)
			{
				motor[motorA]=10;
				motor[motorD]=10;
			}
			motor[motorA]=0;
			motor[motorD]=0;
			current_position*=2;
		}
	}

	fix();
	Turn(degree[x][y]-current_degree);
	nMotorEncoder[motorA]=0;
	while (nMotorEncoder[motorA]<160)
	{
		motor[motorA]=10;
		motor[motorD]=10;
	}
	motor[motorA]=0;
	motor[motorD]=0;
	Setball(-1);
	sleep(3000);
	Setball(1);
	while (nMotorEncoder[motorA])
	{
		motor[motorA]=-10;
		motor[motorD]=-10;
	}
	motor[motorA]=0;
	motor[motorD]=0;

	if (stock==1) Turn(0-current_degree);
	if (stock==2) Turn(2-current_degree);
	if (stock==4) Turn(4-current_degree);
	if (stock==3)
	{
		Turn(0-current_degree);
		while (nMotorEncoder[motorA]<650)
		{
			motor[motorA]=10;
			motor[motorD]=10;
		}
		motor[motorA]=0;
		motor[motorD]=0;
		return;
	}
	int temp=stock-1;
	if (stock==4) temp--;
	Return(temp);
	fix();
}
//----------------------------------------------------
task main()
{
	Setball(1);


	displayCenteredTextLine(5,"Which color do you want?");
	displayCenteredTextLine(6,"Blue or Red");
	displayCenteredTextLine(8,"Pressing touchsensor is Blue");
	displayCenteredTextLine(9,"otherwise , Red");
	displayCenteredTextLine(10,"Please choose in 10 seconds");


	mycolor=0;
	for (int i=0;i<800000;i++)
		mycolor+=getTouchValue(noname);

	if (mycolor)
		mycolor=1;
	eraseDisplay();
	if (mycolor) displayTextLine(4,"Robot is Red,player is blue");
	else displayTextLine(4,"Robot is blue,player is red");
	sleep(4000);
//-------------------------------------------------------
//1 is Robot red,0 is Robot blue
//-------------------------------------------------------
	eraseDisplay();
	displayCenteredTextLine(5,"If Robot is first");
	displayCenteredTextLine(6,"Please press touchsensor");
	displayCenteredTextLine(7,"Otherwise player is first");

	first=0;
	for (int i=0;i<800000;i++)
		first+=getTouchValue(noname);

	if (first)
		first=1;

	eraseDisplay();
	if (first)
		displayCenteredTextLine(4,"Robot is first");
	else
		displayCenteredTextLine(4,"Player is first");
	//sleep(4000);
//-------------------------------------------------------
//1 is Robot first
//-------------------------------------------------------

	for (int i=0;i<=4;i++)
		for (int j=0;j<=4;j++)
			current_map[i][j]=0;
	current_position=1;
	current_degree=0;

	belong[1][1]=1; belong[1][2]=1; belong[1][3]=2;
	belong[2][1]=1; belong[2][2]=1; belong[2][3]=2;
	belong[3][1]=3; belong[3][2]=3; belong[3][3]=4;

	degree[1][1]=7; degree[1][2]=1; degree[1][3]=1;
	degree[2][1]=5; degree[2][2]=3; degree[2][3]=3;
	degree[3][1]=5; degree[3][2]=3; degree[3][3]=3;

	position_degree[1][2]=6; position_degree[1][3]=0;
	position_degree[2][1]=2; position_degree[2][4]=0;
	position_degree[3][1]=4; position_degree[3][4]=6;
	position_degree[4][2]=4; position_degree[4][3]=2;

	dx[1]=-1; dy[1]=-1; dx[2]=-1; dy[2]=0; dx[3]=-1; dy[3]=1;  dx[4]=0; dy[4]=1;
	dx[8]=1;  dy[8]=1;  dx[7]=1;  dy[7]=0; dx[6]=1;  dy[6]=-1; dx[5]=0; dy[5]=-1;

	step=4+first;

	while (step)
	{
		while (1)
		{
			if (getTouchValue(S3))
				break;
		}

		displayTextLine(5,"%d %d %d\n",current_map[1][1],current_map[1][2],current_map[1][3]);
		displayTextLine(6,"%d %d %d\n",current_map[2][1],current_map[2][2],current_map[2][3]);
		displayTextLine(7,"%d %d %d\n",current_map[3][1],current_map[3][2],current_map[3][3]);

		if (step!=5)
			Search();
				displayTextLine(5,"%d %d %d\n",current_map[1][1],current_map[1][2],current_map[1][3]);
		displayTextLine(6,"%d %d %d\n",current_map[2][1],current_map[2][2],current_map[2][3]);
		displayTextLine(7,"%d %d %d\n",current_map[3][1],current_map[3][2],current_map[3][3]);
		int position=Think();
		displayCenteredTextLine(4,"%d %d %d %d",position,step,((position-1)/3)+1,(position-1) % 3 +1);
		int x=((position-1)/3)+1;
		int y=(position-1) % 3 +1;
		current_map[x][y]=1;
		Move_to(x,y);
		if (Judge())
			break;
		step--;
	}
}
